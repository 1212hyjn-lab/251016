대문자 시작은 타입?
✔타입 = int. boolean. string
String -> text   :: 자연어                            머신입장에서 외국어
int -> number  :: 정수, 기계어                           모
float -> number :: 소수점, 기계어                       모
알파벳 하나 = 캐릭터 ('a')  ::글자그자체                모
boolean -> 0,1 = 참과거짓                                 모

외국어는 대문자로 타입을 표기함
기계어는 소문자

--------------------------------------------------------

대문자는 Family name느낌
같은 타입끼리는 주고받을 수 있는데 변수 안에 벨류를 주고 받음

subject와 object
객체(object) : 기능과 속성의 집합 - 메서드와 데이터의 집합

subject는 기계, object는 사람(인간)

즉, 대문로 쓰여진 타입은 인간의 언어로 클래스가 존재한다

-------------------------------------------------------------

String opode -> 스트링이 성이 되니까 '박' 같은 느낌
성과 이름을 같이 두는 것이 실존하는 것이 돼

✔실존의 의미 : 이병헌이 화면에 담기면 실존하는 것이 아니다
실제 이병헌은 어디에 있을 것이고 하나의 존재이다. 근데 웹으로 보는 이병헌은 어디에나 뿌려져 있기 때문에 실존한다고 볼 수 없다
= 이것이 컴퓨터에서의 실존이다
=vitual

그럼 vitual과 fake는 뭘까
original의 copy가 vitual이다. (오리지널의 카피본)
fake는 original도 없음

reference :: 참조한다 -> 원본을 참조한다
참조하기 위해서 원본은 adress가 있어야 한다

예)
![[Pasted image 20251016100158.png]]
여기서 원본은 맨 앞에 Scanner가 된다. _ 디스크에 있음_
뒤에 scanner는 실존(이름)이다  _메모리의 주소_
(설명 :: 스케너는 이미 JDK에 존재하고 있다)

이름을 모르면 존재하지 않는다고 함

Calc = 클래스명 // 타입(내 이름이 아니니까)

메모리의 실존하는 것만 이름을 갖는 것임
런을 해야 메모리에 로딩됌

유투브를 찍어서 올리면 이것은 메모리 그 사람은 자체는 디스크로 봐야해

두 세계관의 이동을 save

메모리는 인간 / 신은 디스크
신의 모양을 따서 만든 것이 인간이기 때문에 
즉 원본이 신임

✔원본의 카피가 존재하는 것이 실존임
실존은 실제로 돌아다니는 것

int는 메모리세계관에서는 원래 있던 존재이기 때문에 new라고 생성해서 새 주소를 생성할 필요가 없는 것임, 그러나 String은 객체이잖아 디스크세계관에 존재하는 것이니까 주소가 필요한거야 그래서 int다음에는 num1이 바로 나오는 것이야.
------------------------------------------------------------------------------

( int result )
여기에다가 한 번 담은 값은 이름을 같이 했을 때 오류가 난다
result를 세 개 더 붙혓을때 오류가 난 것처럼

int 다음에 있는 result는 변수라고 한다

-------------------------------------------------------

설계도는 클래스
클래스를 바탕으로 실체를 뜻하는 것이 인스턴스
메모리 입장에서 실체를 뜻한다
= 인스턴스는 객체의 이름이다 (scanner) <- 일회용이어서 그래
= Scanner 은 타입

다 써지면 그래서 인스턴스는 쓰레기가 된다

Calc는 클래스이름인데 디스크 상에서도 존재한다
그래서 껏다가 켜도 다시 자바에서 켜지잖아

Calc {괄호부터 메모리의 시작임

} -> 이런식으로 그래서 이 괄호 안에서는 이름이나 타입으로 명한다

-------------------------------------------------------------

알고리즘 = 명령의 집합

![[Pasted image 20251016110109.png]]
login.html에 form형식에  action이 나옴

instruction과 statement
statement : 우리가 사용하는 언어의 명령어 (프로그래밍 언어)
instruction : 기계어의 명령어 (cpu명령어)

statement가 instruction으로 바껴야 기계가 알아듣겟지
이런 과정을 우리는 빌드라고 부르는 거야

---------------------------------------------------------------

expression, statements, and blocks의 차이

expression       ; x

statements       ;o

blocks            코드에서 4번줄부터 34번까지를 블록이라고 한다
             메서드도 블록임
         메서드는 statement와 expression이 집합(구성)이다

블록 안에 있는 것들이 메모리로 남길려면 instruction이 되어야 한다.
instruction도 statement와 expression으로 나뉜다

b = s + e

; = 명령의 끝임. cpu에게 실행하라고 명령하는 것

cpu = 계산 기능으로 인텔에서 만들어/ 연산
이런 연산으로 저장해서 다시 불러오는 것을 메모리
영원히 저장하고 싶으면 세이브해서 디스크로

-------------------------------------------------------------

클록펄스

;이 없으면 cpu가 연산을 하지 않고 기다림
즉 expression을 쓰면 cpu가 연산하지 않고 커서가 깜빡이는 것처럼 기다리는 것

자바코드는 식에서 문장 그리고 블록 순으로 확장된다

((실습시작))

계산기에서의 0은 초기값임
int result = 0; 이 그 뜻임
![[Pasted image 20251016114725.png]]
다음에 이렇게 생성
() = 이것은 조건문이야

-절은 케이스라고도 해 = 사칙연산을 하게 되면 절은 4개


------------------------------------------------------------
![[Pasted image 20251016123842.png]]
import가 생성이 안되었다면 main 값을 쳐서 메소드 스콥을 다시 확인해 볼 것.

![[Pasted image 20251016123942.png]]
이건 계산기 코딩인데 참고해 볼 것


주민번호로 성별 맞추는 자바 코드 작성하기 - 과제



==========================================
VO는 휘발돼 -> 보안때문임

DTO와 비교값으로 VO가 서비스에 만나서 비교대상으로써 쓰이고 없어짐


#프롬포트
  
@calculator.html 여기에@gob.html @minus.html @namum.html @plus.html 이것을 합친 화면을 셀렉트 옵션을 사용해서 연산자를 선택하도록 작성해줘


✔서비스에서 화면으로 다시 보낼 것이기 때문에 DTO가 필요가 없다
따라서, Messenger.java만 생성하면 된다.
데이터를 보내는게 아니라 단순히 받은 것을 화면에 송출하는 것이기 때문에

null은 0과 1도 없는 세상이다 -> 전부 다 없던 시절을 의미함
String message = ""; = 주소가 없다
int code = 0;
등호 뒤에 있는 0과 ""은 디폴트이다

그러나 return 뒤에 오는 0은 일정한 값을 가진 것이다

